好 — 這題其實可以用**遞迴 + 記憶化 DP** 配合組合數來做。下面先給出直觀觀察與轉化，然後給出可以直接拿去 AC 的 C++ 範例程式碼（含說明與範例輸入／輸出）。

---

## 關鍵觀察（把問題化簡成子問題）

* 設 (F(n,c,m)) 為題目要求的序列數（前 (n) 桌、每人至少看 (c) 墩、共 (m) 墩）。
* 注意到玩家 1（桌號 1）每一墩都能看到，因此他**會剛好在第 (c) 墩離開**（也就是在第 (c) 墩之後不能再當贏家）。

  * 因此整場比賽的**前 (c) 步**中有 (k) 個是由桌號 (\ge2) 贏（其餘 (c-k) 個是桌 1 贏）。
* 把這 (k) 個桌號 (\ge2) 的勝利按原順序看成是「子序列的前綴」，剩下的 (m-c) 個（在第 (c+1) 步之後發生的）也都是桌號 (\ge2) 的勝利。

  * 因此對桌號 (2..n) 而言，它們在整場的勝利序列長度為 (S_2 = k + (m-c) = m - c + k)。
  * 而這對桌號 (2..n) 的序列必須滿足同樣的規則（每人至少看到 (c)），也就是一個規模縮小的子問題 (F(n-1, c, S_2))。
* 在前 (c) 步中，選出哪 (k) 個位置屬於桌號 (\ge2) 有 (\binom{c}{k}) 種選法；對每一種選法，桌號 (2..n) 的具體有效序列數為 (F(n-1,c,S_2))（且其相對順序已固定為「那 (k) 個在前、其後接上後面 (m-c) 個」）。
* 因此得到遞迴：
  [
  F(n,c,m)=\sum_{k=\max(0,,2c-m)}^{c} \binom{c}{k}\cdot F\bigl(n-1,,c,,m-c+k\bigr),
  ]

  * 下界 (\max(0,2c-m)) 來自於子問題長度 (S_2=m-c+k) 必須至少達到 (c)（否則桌號 2 無法看到 (c) 墩），即 (m-c+k\ge c\Rightarrow k\ge 2c-m)。
* 邊界：當 (n=1) 時，只有桌 1，必須在看到第 (c) 墩就離開；所以當且僅當 (m==c) 時有 1 種序列，否則 0。

這個遞迴搭配記憶化可以高效求解（因為 (c\le102)，且所有測資的 (m) 總和 (\le10^4)）。

---

## 複雜度

狀態大約 (O(n\cdot m))，每個狀態內的迴圈至多 (c) 次，因此總時間在最壞情況約 (O(n\cdot m\cdot c))。在本題限制下可行。程式使用模數 (10^9+7)。

---

## C++ 範例程式（可直接貼上編譯執行）

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MOD = 1000000007;

int addmod(int a,int b){ a+=b; if(a>=MOD) a-=MOD; return a;}
int mulmod(long long a,long long b){ return (int)((a*b)%MOD); }

int nGlobal, cGlobal, mGlobal;
vector<vector<int>> dp; // dp[n][m] = -1 未計算
vector<vector<int>> Cbin; // Cbin[c][k]

int F(int n, int m){
    if (n == 1) return (m == cGlobal) ? 1 : 0;
    if (m < cGlobal) return 0; // 不可能
    int &res = dp[n][m];
    if (res != -1) return res;
    res = 0;
    // k lower bound: k >= max(0, 2c - m)
    int kmin = max(0, 2*cGlobal - m);
    int kmax = cGlobal; // k <= c
    for (int k = kmin; k <= kmax; ++k){
        int S2 = m - cGlobal + k;
        if (S2 < cGlobal) continue; // 子問題不可能
        int sub = F(n-1, S2);
        if (sub == 0) continue;
        int ways = Cbin[cGlobal][k];
        res = addmod(res, mulmod(ways, sub));
    }
    return res;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t;
    if(!(cin>>t)) return 0;
    // max c up to 102 per statement, but compute binomials up to 102
    int CMAX = 105;
    Cbin.assign(CMAX+1, vector<int>(CMAX+1,0));
    for (int i=0;i<=CMAX;i++){
        Cbin[i][0] = Cbin[i][i] = 1;
        for (int j=1;j<i;j++){
            Cbin[i][j] = addmod(Cbin[i-1][j-1], Cbin[i-1][j]);
        }
    }

    while(t--){
        int n,c,m;
        cin>>n>>c>>m;
        nGlobal = n; cGlobal = c; mGlobal = m;
        // quick feasibility: must have c <= m <= n*c
        if (m < c || m > n * c){
            cout << 0 << '\n';
            continue;
        }
        // dp size (n+1) x (m+1)
        dp.assign(n+1, vector<int>(m+1, -1));
        // Make sure Cbin has c computed (we precomputed up to CMAX)
        int ans = F(n, m);
        cout << ans << '\n';
    }
    return 0;
}
```

---

## 範例

輸入：

```
1
2 2 3
```

輸出：

```
2
```

（對應題目中給出的兩個序列 [1,2,2] 與 [2,1,2]）

---

如果你要我把這個 C++ 程式改成 Python、或想要我解釋遞迴的更直觀範例（例如把流程模擬出來看某些 (k) 如何拆解），我可以馬上幫你做 — 想看哪種？

